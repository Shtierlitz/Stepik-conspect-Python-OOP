"""46. Декораторы с параметрами. Сохранение свойств декорируемых функций"""
import math
from functools import wraps
# # дероратор для вычисления производных произвольных ф
# def df_decorator(dx=0.01):
#     def func_decorator(func):
#         @wraps(func)
#         def wraper(x, *args, **kwargs):
#             res = (func(x + dx, *args, **kwargs) - func(x, *args, **kwargs)) / dx
#             return res
#         # wraper.__name__ = func.__name__ # так нужно чтобы сохранить у функций свои имена
#         # wraper.__doc__ = func.__doc__   # так чтобы сохранилось описание (все это если не декорировать wraper)
#         return wraper
#     return func_decorator
#
#
# @df_decorator(dx=0.00001)
# def sin_df(x):
#     """Финкция вычисления производной синуса"""
#     return math.sin(x)
#
# # sin_df = df_decorator(dx=0.00001)(sin_df) # так пишем если не декорируем через @
# df = sin_df(math.pi/3)
# print(df)
# print(sin_df.__name__)
# print(sin_df.__doc__)

"""Подвиг 1. Вводится строка целых чисел через пробел. 
Напишите функцию, которая преобразовывает эту строку в список чисел и возвращает их сумму.

Определите декоратор для этой функции, который имеет один параметр start - начальное значение суммы.
Примените декоратор со значением start=5 к функции и вызовите декорированную функцию для введенной строки s:

s = input()

Результат отобразите на экране.

Sample Input:

5 6 3 6 -4 6 -1
Sample Output:

26"""

# s = input()
#
# def sum_decorator(start = 5):
#     def func_decorator(func):
#         @wraps(func)
#         def wraper(lst, *args, **kwargs):
#             res =  start + func(lst, *args, *kwargs)
#             return res
#         return wraper
#     return  func_decorator
#
# @sum_decorator()
# def sum_str(s):
#     lst = list(map(int, s.split()))
#     return sum(lst)
# sum_dec = sum_str(s)
# print(sum_dec)

"""Подвиг 2. Объявите функцию, которая возвращает переданную ей строку в нижнем регистре (с малыми буквами). 
Определите декоратор для этой функции, который имеет один параметр tag, 
определяющий строку с названием тега и начальным значением "h1". 
Этот декоратор должен заключать возвращенную функцией строку в тег tag и возвращать результат.

Пример заключения строки "python" в тег h1: <h1>python</h1>

Примените декоратор со значением tag="div" к функции и вызовите декорированную функцию для введенной строки s:

s = input()

Результат отобразите на экране.

Sample Input:

Декораторы - это классно!
Sample Output:

<div>декораторы - это классно!</div>"""

# s = input()
# # s = "Декораторы - это классно!"
#
# def div_dec(div = "div"):
#     def func_decorator(func):
#         @wraps(func)
#         def wraper(s):
#             res = f"<{div}>{s.lower()}</{div}>"
#             return res
#         return wraper
#     return func_decorator
# @div_dec()
# def low_string(s):
#     return s.lower()
#
# a1 = low_string(s)
# print(a1)




"""Подвиг 3. Объявите функцию, которая принимает строку на кириллице и преобразовывает ее в латиницу, 
используя следующий словарь для замены русских букв на соответствующее латинское написание:

t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
     'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
     'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
     'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}
Функция должна возвращать преобразованную строку. Замены делать без учета регистра 
(исходную строку перевести в нижний регистр - малые буквы). 

Определите декоратор с параметром chars и начальным значением " !?", который данные символы преобразует в символ "-" и, 
кроме того, все подряд идущие дефисы (например, "--" или "---") приводит к одному дефису. 
Полученный результат должен возвращаться в виде строки.

Примените декоратор с аргументом chars="?!:;,. " к функции и вызовите 
декорированную функцию для введенной строки s:

s = input()

Результат отобразите на экране.

Sample Input:

Декораторы - это круто!
Sample Output:

dekoratory-eto-kruto-"""

t = {'ё': 'yo', 'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ж': 'zh',
     'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p',
     'р': 'r', 'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh',
     'щ': 'shch', 'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'}

# s = "Декораторы - это круто!"
# s = input()
# def decor(chars = "?!:;,. "):
#     def replacer(func):
#         @wraps(func)
#         def wraper(*args):
#             res = func(*args)
#             c = []
#             for i in res:
#                 if i in chars:
#                     c.append("-")
#                 elif i not in chars and i in t.keys():
#                     c.append(t.get(i))
#                 else:
#                     c.append(i)
#             d = "".join(c).replace("---", "-").replace("--", "-")
#             print(d)
#             return res
#
#         return wraper
#     return replacer
#
#
# @decor()
# def string_changer(s):
#     return s.lower()
#
# string_changer(s)

"""Подвиг 4. Объявите функцию с именем get_list и следующим описанием в теле функции:

'''Функция для формирования списка целых значений'''

Сама функция должна формировать и возвращать список целых чисел,
 который поступает на ее вход в виде строки из целых чисел, записанных через пробел.

Определите декоратор, который выполняет суммирование значений 
из списка этой функции и возвращает результат.
Внутри декоратора декорируйте переданную функцию get_list с 
помощью команды @wraps (не забудьте сделать импорт: from functools import wraps). 
Такое декорирование необходимо, чтобы исходная функция get_list сохраняла 
свои локальные свойства: __name__ и __doc__.

Примените декоратор к функции get_list, но не вызывайте ее."""

s = "1 -5 4 12 12.5 44.212121 113"

def decor():
    def summer(func):
        @wraps(func)
        def wraper(*args):
            res = func(*args)


            return sum(res)

        wraper.__name__ = func.__name__
        wraper.__doc__ = func.__doc__
        return wraper
    return summer

@decor()
def get_list(s):
    """Функция для формирования списка целых значений"""
    lst = list(map(float, s.split()))
    c = []
    for i in lst:
        c.append(int(i))
    return c

print(get_list(s))