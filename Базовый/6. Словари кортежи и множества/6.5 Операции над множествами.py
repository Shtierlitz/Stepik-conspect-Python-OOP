"""6.5 Операции над множествами. Сравнение множеств"""
# setA = {1, 2, 3, 4}
# setB = {3, 4, 5, 6, 7}

# результат пересечения множеств
# result = setA & setB  # {3, 4} получаем именно те которые пересекаются/ Создается новый сет
# setA &= setB  - # вариант с "и =" как +=
# setA.intersection(setB) - то же самое. Выводит результат пересечения
# setA.intersection_update()    - сделает setA результатом пересичения как setA &= setB

# обьеденение множеств
# result = setA | setB # - возвращает обьедененное множество {1, 2, 3, 4, 5, 6, 7}
# setA |= setB # - результат обьеденения появится в setA
# result = setA.union(setB) - Аналогично обьединяет множества.

# Вычитание множеств
# print(setA - setB)  # вычтит из первого пересераемые со вторым.
# print(setB - setA)  # вычтет из второго пересекаемые с первым
# setA -= setB    # в setA оставит то что не пересекалось с setB

# Семетричная разность (это уникальные элеенты обоих множеств)
# print(setA ^ setB) # {1, 2, 5, 6, 7} остались только уникальные числа для обеих множеств

# сравнение множеств
# setA = {7, 6, 5, 4, 3}
# setB = {3, 4, 5, 6, 7}
# print(setA == setB) # True
# print(setA != setB) # False

# setA = {7, 6, 5, 4, 3}
# setB = {3, 4, 5}
# print(setB < setA) # True # потому что setB включается в setA
# print(setB > setA) # False # потому что setB невключается в setA
# но если добавить элемент которого нет в обеих множествах будет всегда False
# Если множества равны будет False
# Если множества равны, то можно проверять на >= или <= (имеется ввиду одно входит в другое)

"""Подвиг 1. Вводятся два списка целых чисел каждый с новой строки 
(в строке наборы чисел через пробел). 
Необходимо выбрать и отобразить на экране уникальные числа, 
присутствующие и в первом и во втором списках одновременно. 
Результат выведите на экран в виде строки чисел, записанных по возрастанию через пробел, 
используя команду (здесь s - это множество):

print(*sorted(s))

P. S. О функции sorted мы еще будем говорить, а также об операторе *. 
Пока просто запомните такую возможность сортировки и вывода произвольных коллекций на экран.


Sample Input:

8 11 12 15 -2
4 11 10 15 -5 1 -2
Sample Output:

-2 11 15"""

# print(*sorted(set(map(int, input().split())) & set(map(int, input().split()))))


"""Подвиг 2. Вводятся два списка целых чисел каждый с новой строки 
(в строке наборы чисел через пробел). 
Необходимо выбрать и отобразить на экране уникальные числа, 
присутствующие в первом списке, но отсутствующие во втором. 
Результат выведите на экран в виде строки чисел, записанных по возрастанию через пробел.

Sample Input:

8 5 3 5 -3 1
1 2 3 4
Sample Output:

-3 5 8"""

# s1 = {1, 3, 5, 8, -3}
# s2 = {1, 2, 3, 4}
# s1 = set(map(int, input().split()))
# s2 = set(map(int, input().split()))
# print(*sorted(s1 - s2))

"""Подвиг 3. Вводятся два списка целых чисел каждый с новой строки 
(в строке наборы чисел через пробел). Необходимо выбрать и отобразить на экране уникальные числа, 
присутствующие в первом или втором списках, но отсутствующие одновременно в обоих. 
Результат выведите на экран в виде строки чисел, записанных по возрастанию через пробел.

Sample Input:

1 2 3 4 5
4 5 6 7 8
Sample Output:

1 2 3 6 7 8"""

# s1 = set(map(int, input().split()))
# s2 = set(map(int, input().split()))
# print(*sorted(s1 ^ s2))

"""Подвиг 4. Вводятся два списка городов каждый с новой строки (в строке названия через пробел). 
Необходимо сравнить их между собой на равенство по уникальным (не повторяющимся) городам. 
Если списки содержат одни и те же уникальные города, то вывести на экран ДА, иначе - НЕТ.

Sample Input:

Москва Тверь Уфа Казань Уфа Москва
Уфа Тверь Москва Казань
Sample Output:

ДА"""

# s1 = set(input().split())
# s2 = set(input().split())
# print("ДА" if s2 == s1 else "НЕТ")


"""Подвиг 5. Вводится список оценок студента - его ответов у доски по предмету "Информатика" 
в виде чисел от 2 до 5 в одну строку через пробел. Если студент имеет хотя бы одну двойку, 
то он не допускается до экзамена. Определить на основе введенного списка, допущен ли студент. 
Если допущен, то вывести слово ДОПУЩЕН, иначе - НЕ ДОПУЩЕН. 
При реализации задачи используйте множество для определения наличия двойки.

Sample Input:

3 4 4 5 2 3
Sample Output:

НЕ ДОПУЩЕН"""

# s = set(map(int, input().split()))
# if 2 in s:
#     print("НЕ ДОПУЩЕН")
# else:
#     print("ДОПУЩЕН")

"""Подвиг 6. Вводятся два списка городов каждый с новой строки 
(в строке названия через пробел), которые объехал 
Сергей в 1-й и 2-й годы своего путешествия по России.
 Требуется определить, включал ли его маршрут во 2-й год 
 все города 1-го года путешествия? Если это так, то вывести ДА, иначе - НЕТ.

Sample Input:

Москва Казань Самара Москва
Москва Владимир Новгород Казань Самара Москва
Sample Output:

ДА"""

# s1 = set(input().split())
# s2 = set(input().split())
# print("ДА" if s1 < s2 else "НЕТ")

"""Подвиг 7. Вводится натуральное число, которое может быть 
определено простыми множителями 1, 2, 3, 5 и 7. 
Необходимо разложить введенное число на указанные 
простые множители и проверить, содержит ли оно множители 
2, 3 и 5 (все указанные множители)? Если это так, то вывести ДА, иначе - НЕТ.

Sample Input:

210
Sample Output:

ДА"""
# Мой вариант. Но так не надо. Слишком тяжелая.
# num = 210
# num = int(input())
# s = set()
# check_set = {2, 3, 5}
# for i in range(1, num+1):
#     if num % i == 0:
#         s.add(i)
#         num = num // i
# print("ДА" if s >= check_set else "НЕТ")

# вариант подсмотренный
# num = 210
# check_set = {2, 3, 5}
# s = set()
# num = int(input())
# for i in check_set:
#     if num % i == 0:
#         s.add(i)
#
# print("ДА" if s == check_set else "НЕТ")